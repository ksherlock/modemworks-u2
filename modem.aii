	string asis
	machine m65c02
	case on

	longa off
	longi off

	include 'OMM.equ'
	include 'TimeTool.equ'
	include 'PortTool.equ'
	include 'ConsoleTool.equ'
	include 'W5100.equ'
	include 'dhcp.equ'


*
* Server usage:
*
* & HANGUP [ HangUp]
* & WAIT FOR CALL [IsRinging]
* & PICKUP [AnswerLine / OrigAnswerLine]
* & WAIT FOR CARRIER [HandleConnect]
*
*
* Client usage:
* & CALL "192.168.0.0.1:6502" [DialNumber]
* & WAIT FOR CARRIER [HandleConnect]
*

* Proline (login.b):
* &fn 1 ... 
* & pickup
* & wait for carrier
* ...
* & hangup
*

	macro
&l	cstr &x
&l	dc.b &x, 0
	endm

d0	equ $00

a1	equ $3c
a2	equ $3e
a4	equ $42


prmtbl	equ $e0
lowtr	equ $9b
rndseed	equ $c9

iqerr	equ $e199 ; generate illegal quantity error.


Header	proc

	dc.w $0000 ; header version
	dc.w 'mt' ; unique id
	dc.w end-start ; size
	dc.w start
	dc.w amperct
	dc.w $0000 ; module kind
	dc.w $0000 ; reserved
	dc.w $0000 ; reserved

start

	cmp #MSG_USER
	beq do_user

	cmp #MSG_INIT
	beq do_life
	cmp #MSG_QUIT
	beq do_life
	cmp #MSG_BORN
	beq do_life
	cmp #MSG_INFO
	beq do_info
	cmp #MSG_AMPR
	beq do_ampr
	rts

do_info
	lda a_info
	sta a1
	lda a_info+1
	sta a1+1
	rts

do_life
	; find the time tool ('tt') and serial tool ('pt')
	lda #'t'
	sta a1
	sta a1+1
	ldy #OMM_ID
	ldx #OMM_GETID
	jsr OMMVEC
	stx tt_id

	lda #'p'
	sta a1
	lda #'t'
	sta a1+1
	ldy #OMM_ID
	ldx #OMM_GETID
	jsr OMMVEC
	stx pt_id

	rts


do_user
	tya
	asl a
	tax
	jmp (user_dispatch,x)


do_ampr
; & mset address
ampr_mset
	jmp $d995 ; data - skips to next : or EOL.
;	jsr frmnum
;	jsr getadr
	rts


read_status
	lda #4
	sta $c0b5
	lda #Sn_SR
	sta $c0b6
	lda $c0b7
	rts

command_x
	lda #4
	sta $c0b5
	lda #Sn_CR
	sta $c0b6
	stx $c0b7
	rts

sta_loop
; stores A to $c0b7 Y times.
@loop
	sta $c0b7
	dey
	bne @loop
	rts


store_x_to_IR
; store x to Sn_IR
	lda #4
	sta $c0b5
	lda #Sn_IR
	sta $c0b6
	stx $c0b7
	rts

listen_or_connect
	; x = Sn_CR_LISTEN or Sn_CR_CONNECT
	lda #4
	sta $c0b5
	stz $c0b6
	lda #Sn_MR_TCP
	sta $c0b7
	lda #Sn_CR_DISCON
	sta $c0b7
	dec $c0b6
	lda #Sn_CR_CLOSE
	sta $c0b7
	dec $c0b6
	lda #Sn_CR_OPEN
	sta $c0b7
	lda #$ff
	sta $c0b7 ; clear int flags

	lda #Sn_PORT
	sta $c0b6
	lda rndseed
	sta $c0b7
	inc lport
	lda lport
	sta $c0b7

	lda #Sn_CR
	sta $c0b6
	stx $c0b7
	rts

listen
	sec
	ror server

	ldx #Sn_CR_LISTEN
	jmp listen_or_connect

*
* called by & SLOT (modem-slot)
*
init
* prmtbl[0] = slot

	; should store slot ptrs so it's not hardcoded.

*
* Called by &USR 6
*
reset
	jsr dhcp
	bcc @ok
	lda #1
	rts

@ok
	lda #1
	rts

exit
	ldx #Sn_CR_CLOSE
	jmp command_x


*
* called by &fn 0
*
online
* online: A=1
* offline: A=0

	jsr read_status
	cmp #Sn_SR_SOCK_ESTABLISHED
	bne @no
	lda #1
	rts

;@d
;	lda #Sn_CR
;	sta $c0b6
;	lda #Sn_CR_DISCON
;	sta $c0b7

@no
	lda #0
	rts

;	lda #1
;	rts

has_mnp
	lda #1
	rts
set_mnp
* prmtbl[0]=0 ; disable error correction
* prmtbl[0]=1 ; enable error correction
	rts

*
* Called by & CALL string
*
dial_number
* Input: 
* prmtbl[0] = length of string
* prmtbl[1:2] = address of string
* prmtbl[3] = Touch-Tone (1) or Pulse. [set to 1]

* parse as xx.xx.xx.xx:port


	ldx #6-1
@zloop	stz ip,x
	dex
	bne @zloop

	ldy #0
	ldx #0

	lda prmtbl
	beq @err



	ldy #0
	ldx #0
@loop
	jsr get_num
	pha
	; lda tmp+1
	; bne @bad
	lda tmp
	sta ip,x
	inx
	pla
	cpx #4
	bcs @err

	cmp #'.'
	beq @loop
	cmp #':'
	bne @err

; port
	jsr get_num
	cmp #0
	bne @err
	lda tmp
	sta port
	lda tmp+1
	sta port+1


	lda #4
	sta $c0b5
	lda #Sn_DIPR
	sta $c0b6
	ldx #0
@xloop
	lda ip,x
	sta $c0b7
	inx
	cpx #6
	bne @xloop



	stz server
	ldx #Sn_CR_CONNECT
	jmp listen_or_connect
@err
	rts

get_num
	stz tmp
	stz tmp+1
@loop
	lda (prmtbl+1),y
	cmp #'0'
	bcc @no
	cmp #'9'+1
	bcs @no

	and #$0f
	pha ; save

	asl tmp ; x 2
	rol tmp+1
	lda tmp+1
	pha
	lda tmp
	pha

	asl tmp ; x 4
	rol tmp+1
	asl tmp ; x 8
	rol tmp+1
	clc
	pla
	adc tmp
	sta tmp
	pla
	adc tmp+1
	sta tmp+1
	clc
	pla
	adc tmp
	sta tmp
	lda #0
	adc tmp+1
	sta tmp+1

	iny
	cpy prmtbl
	bcc @loop
	lda #0
	rts
@no
	rts



*
* Called by & PICKUP 2
*
set_busy:
* prmtbl[0] = 0; go on hook
* prmtbl[0] = 1; go off hook
*
	lda prmtbl
	sta busy

	beq @off
	jmp listen

@off
	ldx #Sn_CR_CLOSE
	jmp command_x



*
* Called by & WAIT FOR CARRIER
*
handle_connect
* Input:
* prmtbl[0:1] = seconds to wait
* Output:
* A = result code
* wait until Sn_IR_CON or timeout.

	stz int_flag
	jsr handle_connect_cb
	bcs @check

@wait
	lda a_handle_connect_cb
	sta prmtbl+2
	lda a_handle_connect_cb+1
	sta prmtbl+3

	ldx tt_id
	ldy #WaitSeconds
	jsr OMMVEC

	bcc @to
@check
	lda int_flag
;	bit #Sn_IR_TIMEOUT
;	bne @to
	bit #Sn_IR_CON
	bne @ok
	; ????
@to
	jsr listen
	lda #2 ; no connection.
	rts

@ok
	; clear the connect int. bit
	ldx #Sn_IR_CON
	jsr store_x_to_IR
	lda #0 ; connection established
	rts

handle_connect_cb
	lda #4
	sta $c0b5
	lda #Sn_IR
	sta $c0b6
	lda $c0b7
	sta int_flag
	and #(Sn_IR_CON or Sn_IR_TIMEOUT)
	cmp #1
	rts


*
* called by & PICKUP [0]
*
answer_line
* pick up the phone and send answer carrier tone
	stz mode
answer_common
	; clear the connect int. bit [????]
	ldx #Sn_IR_CON
	jmp store_x_to_IR

*
* Called by & PICKUP 1
*
orig_ans_line
	lda #1
	sta mode
	bra answer_common

*
* called by & HANGUP
*
hang_up
	jmp listen


*
* Called by & FN 1
* Called by & WAIT FOR CALL
is_ringing
* C=0; no ring
* C=1; ring detected.


* "ring" if server mode and Sn_IR_CON flag set.

	lda server
	beq @no

	lda #4
	sta $c0b5
	lda #Sn_IR
	sta $c0b6
	lda $c0b7
	and #Sn_IR_CON
	beq @no
	sec
	rts


@no
	clc
	rts


*
* Called by & USR 3/4/5
*
set_speaker
* prmtbl[0] = speaker mode
	rts

*
* Called by & FN 3
*
get_mode
	lda mode ; answer mode
	rts
*
* Called by & FN 6
*
modem_type
	lda #1 ; internal
	rts



set_modem
* prmtbl[0:1] = address of modem cap
	rts

*
* Called by & SPEED=
*
set_modem_speed
* prmtbl[0] = speed
	rts

*
* called by & WAIT FOR STRING to clear modem string search.
*
remove_search_strings
* undocumented.
	rts

*
* Called by & FN 9 , & FN 2
*
connect_speed
* output:
* A = speed
	lda #15 ; 19200
	sta prmtbl
	rts

*
* Called by & FN 128
*
connect_speed_cstr
* output:
* prmtbl[0:1] = c-str of the connect speed

	lda a_connect_speed_str
	sta prmtbl
	lda a_connect_speed_str+1
	sta prmtbl+1
	rts


dhcp
	; re-set, enable auto-increment mode

	lda #$80
	sta $c0b4
	nop
	nop
	lda #$03
	sta $c0b4
	; give all memory to socket 0

	lda #RMSR
	stz $c0b5
	sta $c0b6
	lda #%00000011 ; 8k for the socket
	sta $c0b7 ; RMSR
	sta $c0b7 ; TMSR

	; set the MAC address...
	lda #SHAR
	sta $c0b6
	ldy #0
@mloop
	lda mac,y
	sta $c0b7
	iny
	cpy #6
	bne @mloop

; socket 1 = UDP, broadcast
	lda #$04
	sta $c0b5
	stz $c0b6

	lda #Sn_MR_UDP
	sta $c0b7

; source port
	lda #Sn_PORT
	sta $c0b6
	stz $c0b7
	lda #68
	sta $c0b7

; set dest ip/mac to $ff
	ldy #6+4
	lda #$ff
	jsr sta_loop

	; dest port
	stz $c0b7
	lda #67
	sta $c0b7

; now open UDP
	lda #Sn_CR
	sta $c0b6
	lda #Sn_CR_OPEN
	sta $c0b7

	lda #5
	sta dhcp_retry

discover
	jsr send_dhcp_discover	

	jsr wait_2_seconds
	bcs @check
	; timeout
@retry	dec dhcp_retry
	bne discover
	jmp dhcp_error
@check
	; check for a DHCP offer.
	; if present, pull out the dhcp ip address and our ip address.

	jsr read_message
	cmp #DHCP_OFFER
	beq request
	bra @retry
	; todo -- should call read_message until RSR == 0

request
	jsr send_dhcp_request
	jsr wait_2_seconds
	bcs @check
	; timeout
@retry	dec dhcp_retry
	bne request
	jmp dhcp_error

@check
	; check for an ACK
	; if present, pull out the dhcp ip address and our ip address.

	jsr read_message
	cmp #DHCP_ACK
	beq @ok
	bra @retry

	;

@ok	jmp dhcp_commit
;	rts

dhcp_error
	sec
	rts

wait_2_seconds
	; 2-second wait...
	lda #2
	sta prmtbl
	stz prmtbl+1
	lda a_data_avail
	sta prmtbl+2
	lda a_data_avail+1
	sta prmtbl+3
	ldy #WaitSeconds
	ldx tt_id
	jmp OMMVEC

data_avail
	; called from WaitTick callback
	; returns carry set to cancel the wait

	lda #4
	sta $c0b5
	lda #Sn_IR
	sta $c0b6
	lda $c0b7
	sta int_flag
	and #Sn_IR_RECV
	cmp #1
	rts


	if 0 then
	clc
	lda #$04
	sta $c0b5
	lda #Sn_RX_RSR
	sta $c0b6
	lda $c0b7
	ora $c0b7
	beq @no
	sec
@no	rts
	endif


	

send_dhcp_discover

	jsr send_dhcp_common

	; dhcp data
	ldy #0
@dloop
	lda dhcp_disc_pl,y
	sta $c0b7
	iny
	cpy #dhcp_disc_pl_len
	bne @dloop

;@len	equ dhcp_disc_pl_len+236

	lda #04
	sta $c0b5
	lda #Sn_TX_WR
	sta $c0b6

	clc
	lda a1
	adc #(dhcp_disc_pl_len+236)
	sta a1
	lda a1+1
	adc #(dhcp_disc_pl_len+236)>>8
	sta a1+1

	sta $c0b7
	lda a1
	sta $c0b7

	ldx #Sn_CR_SEND_MAC
	jmp command_x

send_dhcp_request

	ldy #3
@iloop	lda ip_address,y
	sta req_ip,y
	lda dhcp_address,y
	sta req_server_ip,y
	dey
	bpl @iloop

	jsr send_dhcp_common

	; dhcp data
	ldy #0
@dloop
	lda dhcp_req_pl,y
	sta $c0b7
	iny
	cpy #dhcp_req_pl_len
	bne @dloop

	lda #04
	sta $c0b5
	lda #Sn_TX_WR
	sta $c0b6

	clc
	lda a1
	adc #(dhcp_req_pl_len+236)
	sta a1
	lda a1+1
	adc #(dhcp_req_pl_len+236)>>8
	sta a1+1

	sta $c0b7
	lda a1
	sta $c0b7

	ldx #Sn_CR_SEND_MAC
	jmp command_x

send_dhcp_common

	lda #$04
	sta $c0b5
	lda #Sn_TX_WR
	sta $c0b6
	lda $c0b7
	sta a1+1
	lda $c0b7
	sta a1

	lda a1+1
	and #$1f
	ora #$40
	sta $c0b5
	lda a1
	sta $c0b6

	; now points to start of the buffer.
	ldy #0
@hloop
	lda bootp_hdr,y
	sta $c0b7
	iny
	cpy #bootp_hdr_len
	bne @hloop

	; 0-pad until mac address @28
	ldy #28-bootp_hdr_len
	lda #0
	jsr sta_loop

	; mac address
	ldy #0
@mloop
	lda mac,y
	sta $c0b7
	iny
	cpy #6
	bne @mloop

	; 0-pad until cookie at 236
	ldy #236-34
	lda #0
	jmp sta_loop



set_rx_ptr
	; prepare for reading a1+a from the rx buffer
	clc
	adc a1
	sta $c0b6
	lda #0
	adc a1+1
	and #$7f
	ora #$60
	sta $c0b5
	rts

read_message
	; read a message from the w5100.
	; returns dhcp message type in A / -1 on error.

	; udp header:
	; ip address / port / size

	; set IDM address to rd buffer.


	; a1 = Sn_RX_RD
	lda #4
	sta $c0b5
	lda #Sn_RX_RD
	sta $c0b6
	lda $c0b7
	sta a1+1
	lda $c0b7
	sta a1

	; skip ip/port (6 bytes)
	lda #6
	jsr set_rx_ptr


	; payload size
	lda $c0b7
	sta a2+1
	lda $c0b7
	sta a2
	; s/b > 240 bytes
	lda a2+1
	bne rm_ok
	lda a2
	cmp #240
	bcs rm_ok

rm_bad
	ldy #-1
rm_exit
	; add 8-bytes for header
	lda a1
	clc
	adc #8
	sta a1
	lda #0
	adc a1+1
	sta a1+1
	; add length
	lda a1
	clc
	adc a2
	sta a1
	lda a1+1
	adc a2+1
	sta a1+1
	lda #4
	sta $c0b5
	lda #Sn_RX_RD
	sta $c0b6
	lda a1+1
	sta $c0b7
	lda a1
	sta $c0b7
	ldx #Sn_IR_RECV
	jsr store_x_to_IR
	ldx #Sn_CR_RECV
	jsr command_x

	tya
	rts



rm_ok

	; check the xid - offset 4

check_xid
	lda #8+4
	jsr set_rx_ptr
	ldy #0
@loop	lda $c0b7
	cmp xid,y
	bne rm_bad
	iny
	cpy #4
	bne @loop

check_ip
	; ip address
	lda #8+16
	jsr set_rx_ptr
	ldy #0
@loop	lda $c0b7
	sta ip_address,y
	iny
	cpy #4
	bne @loop

check_cookie
	; check the cookie
	lda #236+8
	jsr set_rx_ptr
	ldy #0
@loop	lda $c0b7
	cmp cookie,y
	bne rm_bad
	iny
	cpy #4
	bne @loop


	; parse the options.  only looking for 
	; message type = offer
	; dhcp server id
oloop
	lda $c0b7
	beq oloop ; pad option
	cmp #-1
	beq oend
	ldx #4*2
@loop
	cmp option_table,x
	beq @dispatch
	dex
	dex
	bpl @loop

; unknown option - read length byte and skip over it.
	ldx $c0b7 ; len byte
	jsr skipx0
	bra oloop

@dispatch
	lda $c0b7 ; length
	jmp (option_dispatch,x)	

oend
	ldy dhcp_msg_type
	jmp rm_exit


option_1 ; subnet mask
	; +---+---+------+
	; | 1 | 4 | mask |
	; +---+---+------+
	ldy #0
@loop	lda $c0b7
	sta subnet_mask,y
	iny
	cpy #4
	bne @loop
	jmp oloop

option_3 ; router
	; +---+---+------------+
	; | 3 | n | address... |
	; +---+---+------------+
	tax  ; save length for now...
	ldy #0
@loop	lda $c0b7
	sta gateway_address,y
	iny
	dex
	cpy #4
	bne @loop

	; may be > 1 router
	jsr skipx0
	jmp oloop

option_6 ; dns server
	; +---+---+------------+
	; | 3 | n | address... |
	; +---+---+------------+
	tax  ; save length for now...
	ldy #0
@loop	lda $c0b7
	sta dns_address,y
	iny
	dex
	cpy #4
	bne @loop

	; may be > 1 router
	jsr skipx0
	jmp oloop

option_53 ; dhcp message type
	; +----+---+----+
	; | 53 | 1 | xx |
	; +----+---+----+
	lda $c0b7
	sta dhcp_msg_type
	jmp oloop

option_54
	; server identity
	; +----+---+---------+
	; | 54 | 4 | address |
	; +----+---+---------+

	ldy #0
@loop	lda $c0b7
	sta dhcp_address,y
	iny
	cpy #4
	bne @loop
	jmp oloop




;
; read (and discard) x bytes from $c0b7. 
;
skipx0
	cpx #0
	beq skip_rts
skipx
@loop	lda $c0b7
	dex
	bne @loop
skip_rts
	rts



dhcp_commit
;
; update values in the wiznet
;
	stz $c0b5
	lda #GAR
	sta $c0b6

	ldy #0
@loop1	lda gateway_address,y
	sta $c0b7
	iny
	cpy #4
	bne @loop1

	ldy #0
@loop2	lda subnet_mask,y
	sta $c0b7
	iny
	cpy #4
	bne @loop2

	lda #SIPR
	sta $c0b6
	ldy #0
@loop3	lda ip_address,y
	sta $c0b7
	iny
	cpy #4
	bne @loop3

; send message to set DNS?

; close the socket
	lda #4
	sta $c0b5
	lda #Sn_CR
	sta $c0b6
	lda #Sn_CR_CLOSE
	sta $c0b7

	clc
	rts




	dc.b 0

*
* immediate section
*

a_info	dc.w info
a_connect_speed_str
	dc.w connect_speed_str
a_handle_connect_cb
	dc.w handle_connect_cb

a_data_avail dc.w data_avail


user_dispatch
	dc.w init
	dc.w exit
	dc.w online
	dc.w has_mnp
	dc.w dial_number
	dc.w set_busy
	dc.w handle_connect
	dc.w answer_line
	dc.w hang_up
	dc.w is_ringing
	dc.w set_mnp
	dc.w orig_ans_line
	dc.w reset
	dc.w set_speaker
	dc.w get_mode
	dc.w modem_type
	dc.w connect_speed
	dc.w set_modem
	dc.w set_modem_speed
	dc.w remove_search_strings
	dc.w connect_speed_cstr

option_dispatch
	dc.w option_1,option_3,option_6,option_53,option_54


	dc.w 0

*
* data section
*

	msb on
info	cstr '&SYSDATE Modem (W5100) 1.0'
	msb off

connect_speed_str cstr '19200'


amperct
	dc.b 'MSET',0
	dc.b -1


tt_id	dc.b 0
pt_id	dc.b 0

server	dc.b 0
mode	dc.b 0
busy	dc.b 0


ip	dc.l 0
port	dc.w 0

; local port; incremented w/ connect/listen.
; other half is from RND seed. (and adjusted by RND())
lport	dc.b $00

tmp	dc.w 0
int_flag	dc.b 0


dhcp_retry	dc.b 0

dhcp_msg_type	dc.b 0
subnet_mask	dc.l 0
dhcp_address	dc.l 0
gateway_address	dc.l 0
ip_address	dc.l 0
dns_address	dc.l 0

option_table
	dc.w 1,3,6,53,54



mac	dc.b $00,$08,$dc,$a2,$a2,$a2

bootp_hdr ; boot req, ethernet, hw len 6, 0 hops
	dc.b $01,$01,$06,$00
xid	dc.b $12,$34,$56,$78 ; xid
	dc.b $00,$00,$80,00 ; seconds elapsed, flags (broadcast)
bootp_hdr_len equ *-bootp_hdr

dhcp_disc_pl ; cookie + discover + parm list
	dc.b $63,$82,$53,$63,$35,$01,$01,$37
	dc.b $04,$01,$03,$06,$1a,$ff
dhcp_disc_pl_len equ *-dhcp_disc_pl


dhcp_req_pl ; cookie + req + parm list

cookie	dc.b $63,$82,$53,$63
	dc.b $35,$01,$03,$37
	dc.b $04,$01,$03,$06,$1a,$39,$02,$05
	dc.b $b4,$36,$04
req_server_ip
	dc.b $ff,$ff,$ff,$ff ; dhcp server id
	dc.b $32,$04
req_ip
	dc.b $ff,$ff,$ff,$ff ; req. ip
	dc.b $ff
dhcp_req_pl_len equ *-dhcp_req_pl



end
	endp
	end
